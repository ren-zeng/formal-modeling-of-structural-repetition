<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{figureName}}</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow-x: hidden;
        }
        #myPlot {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            padding: 10px;
        }
        svg {
            width: 100%;
            height: auto;
            max-height: 100vh;
        }
        .tooltip {
            position: absolute;
            background-color: white;
            padding: 8px;
            border: 1px solid #ddd;
            pointer-events: none;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 100;
            max-width: 200px;
        }
        .button-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 10;
        }
        @media (max-width: 768px) {
            .button-container {
                position: static;
                margin: 10px 0;
                justify-content: center;
            }
        }
        .save-button {
            padding: 8px 16px;
            background-color: #69b3a2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            touch-action: manipulation;
        }
        .save-button:hover {
            background-color: #85c7b5;
        }
        .feature-bar {
            transition: opacity 0.2s, stroke-width 0.2s;
        }
        .feature-bar.highlighted {
            stroke-width: 2px;
            stroke: #000;
        }
        .category-legend-item, .feature-legend-item {
            cursor: pointer;
        }
        .legend-rect.highlighted {
            stroke-width: 1px;
            stroke: #000;
        }
        .legend-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding-right: 10px;
        }
    </style>
</head>

<body>
    <div id="myPlot">
        <div class="button-container">
            <button class="save-button" onclick="saveSVG()">Save as SVG</button>
            <button class="save-button" onclick="savePDF()">Save as PDF</button>
        </div>
    </div>
    <script>
    // Set margins and dimensions
    const margin = {top: 50, right: 150, bottom: 50, left: 150};
    const width = 800 - margin.left - margin.right;
    const height = 300 - margin.top - margin.bottom;

    // Create SVG element
    const svg = d3.select("#myPlot")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

    // Create tooltip
    const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

    // Process the data
    const rawData = {{{dataSet}}};

    // Transform the data for stacking
    const transformedData = rawData.map(item => ({
        {{_X}}: item.{{_X}},
        {{_C}}: item.{{_C}},
        {{_Y}}: item.{{_Y}},
        ruleDepths: item.ruleDepths // Include the ruleDepths array for histogram
    }));
    
    // Process by category first
    const categoryGroups = d3.group(transformedData, d => d.{{_C}});
    
    // Create category data with totals
    const categoryData = Array.from(categoryGroups, ([category, values]) => {
        // Sum frequencies for this category
        const total = d3.sum(values, d => d.{{_Y}});
        
        // Get features for this category
        const features = Array.from(d3.group(values, d => d.{{_X}}), ([feature, featureValues]) => ({
            feature: feature,
            frequency: d3.sum(featureValues, d => d.{{_Y}}),
            category: category
        }));
        
        // Sort features by frequency
        features.sort((a, b) => b.frequency - a.frequency);
        
        return {
            category: category,
            total: total,
            features: features
        };
    });
    
    // Sort categories by total frequency
    categoryData.sort((a, b) => b.total - a.total);
    
    // Get unique categories and stack keys
    const categories = categoryData.map(d => d.category);
    
    // Create Y scale (categories)
    const y = d3.scaleBand()
        .range([0, height])
        .domain(categories)
        .padding(0.2);
    
    // Create a nested Y scale for features within each category
    const yFeature = {};
    categoryData.forEach(cat => {
        const features = cat.features.map(f => f.feature);
        yFeature[cat.category] = d3.scaleBand()
            .domain(features)
            .range([0, y.bandwidth()])
            .padding(0.05);
    });
    
    // Draw Y axis (categories)
    svg.append("g")
        .call(d3.axisLeft(y));

    // Add Y axis label
    svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left + 40)
        .attr("x", -height/2)
        .attr("text-anchor", "middle")
        .text("{{xLabel}}");

    // Create X scale (values)
    const x = d3.scaleLinear()
        .domain([0, d3.max(categoryData, d => d.total)])
        .range([0, width]);
    
    // Draw X axis
    svg.append("g")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(x));

    // Add X axis label
    svg.append("text")
        .attr("x", width/2)
        .attr("y", height + 40)
        .attr("text-anchor", "middle")
        .text("{{yLabel}}");

    // Add chart title
    svg.append("text")
        .attr("x", width/2)
        .attr("y", -20)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text("{{figureName}}");

    // Color scale for categories
    const colorCategory = d3.scaleOrdinal()
        .domain(categories)
        .range(d3.schemeCategory10);
        
    // Color scale for features (with a different palette)
    const allUniqueFeatures = [...new Set(transformedData.map(d => d.{{_X}}))];
    const colorFeature = d3.scaleOrdinal()
        .domain(allUniqueFeatures)
        .range(d3.schemeSet3);

    // Draw category bars (background)
    const categoryBars = svg.selectAll(".category-group")
        .data(categoryData)
        .join("g")
        .attr("class", "category-group")
        .attr("transform", d => `translate(0, ${y(d.category)})`);
        
    // Add border rectangle for each category to visually group feature bars
    categoryBars.append("rect")
        .attr("class", "category-border")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", d => x(d.total))
        .attr("height", y.bandwidth())
        .attr("fill", "none")
        .attr("stroke", "#333")
        .attr("stroke-width", 0);
    
    // Draw feature bars (within each category)
    categoryBars.each(function(cat) {
        const catGroup = d3.select(this);
        
        // Track starting position for each feature bar
        let xPosition = 0;
        
        // Add bars for each feature in this category
        cat.features.forEach(feature => {
            // Calculate the width of this feature bar
            const barWidth = x(feature.frequency);
            
            // Create safe feature name for CSS class
            const safeFeatureName = (feature.feature || "").toString().replace(/\s+/g, '-');
            
            // Only add feature bars with sufficient width
            const featureBar = catGroup.append("rect")
                .attr("class", `feature-bar feature-${safeFeatureName}`)
                .attr("data-category", cat.category)
                .attr("data-feature", feature.feature)
                .attr("x", xPosition)
                .attr("y", 0) // Start from top of category bar area
                .attr("width", barWidth)
                .attr("height", y.bandwidth()) // Use full category bar height
                .attr("fill", colorFeature(feature.feature))
                .attr("stroke", "#333")
                .attr("stroke-width", 0.5)
                .on("mouseover", function(event) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 0.9);
                    tooltip.html(`Category: ${cat.category}<br>Feature: ${feature.feature}<br>Frequency: ${feature.frequency}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });
            
            // Add label to the bar segment if there's enough space
            if (barWidth > 40) { // Only add text if the bar is wide enough
                catGroup.append("text")
                    .attr("class", "feature-label")
                    .attr("x", xPosition + barWidth/2)
                    .attr("y", y.bandwidth()/2)
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle")
                    .attr("fill", "#000")
                    .style("font-size", "12px")
                    .style("pointer-events", "none")
                    .text(feature.feature);
            }
            
            // Update x position for features to be stacked horizontally
            xPosition += barWidth;
        });
    });
    
    // Add legend for categories
    const categoryLegend = svg.append("g")
        .attr("font-size", "14px")
        .attr("text-anchor", "start")
        .selectAll(".category-legend")
        .data(categories)
        .enter().append("g")
        .attr("class", "category-legend-item")
        .attr("data-category", d => d)
        .attr("transform", (d, i) => `translate(${width + 20}, ${i * 20})`)
        .on("mouseenter", function(event, category) {
            // Highlight the legend item
            d3.select(this).select("rect")
                .classed("highlighted", true);
            d3.select(this).select("text")
                .classed("highlighted", true);
                
            // Highlight all bars for this category in the main plot
            d3.selectAll(`.feature-bar[data-category="${category}"]`)
                .classed("highlighted", true);
                
            // Highlight corresponding histogram bars
            d3.selectAll(`.histogram-bar[data-category="${category}"]`)
                .classed("highlighted", true);
                
            // Fade other categories in both plots
            d3.selectAll(`.feature-bar:not([data-category="${category}"])`)
                .style("opacity", 0.3);
            d3.selectAll(`.histogram-bar:not([data-category="${category}"])`)
                .style("opacity", 0.3);
        })
        .on("mouseleave", function(event, category) {
            // Reset legend highlighting
            d3.select(this).select("rect")
                .classed("highlighted", false);
            d3.select(this).select("text")
                .classed("highlighted", false);
                
            // Reset bar highlighting in both plots
            d3.selectAll(".feature-bar")
                .classed("highlighted", false)
                .style("opacity", 1);
            d3.selectAll(".histogram-bar")
                .classed("highlighted", false)
                .style("opacity", 1);
        });

    categoryLegend.append("rect")
        .attr("class", "legend-rect")
        .attr("width", 15)
        .attr("height", 15)
        .attr("fill", d => colorCategory(d));

    categoryLegend.append("text")
        .attr("class", "legend-text")
        .attr("x", 20)
        .attr("y", 10)
        .text(d => d);
        
    // Extract all unique features for the legend instead of just top N
    // First collect all features from all categories with their frequencies
    const allFeaturesWithFreq = categoryData.flatMap(cat => 
        cat.features.map(f => ({
            feature: f.feature,
            frequency: f.frequency
        }))
    );
    
    // Remove duplicates by creating a Map with feature as key and keeping highest frequency
    const featureFreqMap = new Map();
    allFeaturesWithFreq.forEach(item => {
        if (!featureFreqMap.has(item.feature) || 
            featureFreqMap.get(item.feature).frequency < item.frequency) {
            featureFreqMap.set(item.feature, item);
        }
    });
    
    // Convert back to array and sort by frequency (descending) to match bar plot appearance
    const allFeaturesSorted = Array.from(featureFreqMap.values())
        .sort((a, b) => b.frequency - a.frequency)
        .map(item => item.feature);
    
    // Calculate dynamic SVG height based on content
    const chartHeight = height + margin.top + margin.bottom;
    // Add height for the histogram with more spacing
    const histogramHeight = 200;
    const spacingBetweenPlots = 100; // Increased spacing between plots
    const legendHeight = Math.max(500, (categories.length + allFeaturesSorted.length + 3) * 20); // Reasonable height limit
    const svgHeight = Math.max(chartHeight + histogramHeight + spacingBetweenPlots + 50, legendHeight);
    
    // Update SVG height to accommodate all legends and the histogram
    d3.select("#myPlot svg").attr("height", svgHeight);
    
    // Create container for histogram with increased spacing
    const histogramContainer = svg.append("g")
        .attr("class", "histogram-container")
        .attr("transform", `translate(0, ${height + spacingBetweenPlots})`);
    
    // Add title for the histogram
    histogramContainer.append("text")
        .attr("x", width/2)
        .attr("y", -30)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text("Depth Distribution of Rule Category (normalized by tree depth)");
    
    // Process data for the histogram
    // Extract rule depths from the data - need to flatten the ruleDepths arrays
    const ruleDepths = [];
    transformedData.forEach(d => {
        // Check if ruleDepths exists and is an array
        if (d.ruleDepths && Array.isArray(d.ruleDepths)) {
            d.ruleDepths.forEach(depth => {
                ruleDepths.push({
                    depth: depth,
                    category: d.{{_C}},
                    feature: d.{{_X}},
                    frequency: d.{{_Y}} / d.ruleDepths.length // Distribute frequency across depth values
                });
            });
        }
    });
    
    // Get unique depth values and sort them
    const uniqueDepths = Array.from(new Set(ruleDepths.map(d => d.depth))).sort((a, b) => a - b);
    
    // Define custom bin thresholds based on the unique depth values
    // Using fixed bins from 0 to 1
    const minDepth = 0;
    const maxDepth = 1;
    const binCount = 10; // Number of bins to divide the 0-1 range
    
    // Create evenly spaced bin thresholds from 0 to 1
    const binThresholds = Array.from({length: binCount + 1}, (_, i) => i / binCount);
    
    // Create X scale for histogram with fixed range from 0 to 1
    const histogramX = d3.scaleLinear()
        .domain([minDepth, maxDepth])
        .range([0, width]);
    
    // Create bin containers
    const bins = [];
    for (let i = 0; i < binThresholds.length - 1; i++) {
        bins.push({
            x0: binThresholds[i],
            x1: binThresholds[i + 1],
            data: []
        });
    }
    
    // Place depth values into bins
    ruleDepths.forEach(item => {
        // Find the appropriate bin
        const bin = bins.find(b => item.depth >= b.x0 && (item.depth < b.x1 || 
            (item.depth === b.x1 && b.x1 === d3.max(uniqueDepths))));
        
        if (bin) {
            bin.data.push(item);
        }
    });
    
    // Count by category within each bin
    bins.forEach(bin => {
        // Initialize category counts
        bin.categories = categories.map(category => ({
            category,
            sum: 0
        }));
        
        // Count frequencies by category
        bin.data.forEach(item => {
            const categoryObj = bin.categories.find(c => c.category === item.category);
            if (categoryObj) {
                categoryObj.sum += item.frequency;
            }
        });
        
        // Calculate total for this bin
        bin.total = d3.sum(bin.categories, d => d.sum);
    });
    
    // Create the X axis for the histogram
    histogramContainer.append("g")
        .attr("transform", `translate(0, ${histogramHeight})`)
        .call(d3.axisBottom(histogramX)
            .tickValues(binThresholds)
            .tickFormat(d3.format(".2f")));
    
    // X axis label
    histogramContainer.append("text")
        .attr("x", width/2)
        .attr("y", histogramHeight + 40)
        .attr("text-anchor", "middle")
        .text("Rule Depth");
    
    // Create Y scale for histogram
    const histogramY = d3.scaleLinear()
        .domain([0, d3.max(bins, d => d.total) || 1])
        .range([histogramHeight, 0]);
    
    // Create the Y axis for the histogram
    histogramContainer.append("g")
        .call(d3.axisLeft(histogramY));
    
    // Y axis label
    histogramContainer.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left + 40)
        .attr("x", -histogramHeight/2)
        .attr("text-anchor", "middle")
        .text("Frequency");
    
    // Draw the stacked histogram
    bins.forEach(bin => {
        let y0 = 0; // Starting y position for stacking
        
        // Sort categories to match main plot order
        bin.categories.sort((a, b) => {
            const categoryA = categories.indexOf(a.category);
            const categoryB = categories.indexOf(b.category);
            return categoryA - categoryB;
        });
        
        bin.categories.forEach(categoryData => {
            // Skip if sum is 0
            if (categoryData.sum === 0) return;
            
            const binWidth = histogramX(bin.x1) - histogramX(bin.x0);
            const effectiveWidth = binWidth * 0.9; // 90% of bin width to add padding
            
            histogramContainer.append("rect")
                .attr("class", "histogram-bar")
                .attr("data-bin", `${bin.x0.toFixed(2)}-${bin.x1.toFixed(2)}`)
                .attr("data-category", categoryData.category)
                .attr("x", histogramX(bin.x0) + (binWidth * 0.05)) // 5% padding on each side
                .attr("width", effectiveWidth)
                .attr("y", histogramY(y0 + categoryData.sum))
                .attr("height", histogramY(y0) - histogramY(y0 + categoryData.sum))
                .attr("fill", colorCategory(categoryData.category))
                .attr("stroke", "#333")
                .attr("stroke-width", 0.5)
                .on("mouseover", function(event) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 0.9);
                    tooltip.html(`Depth range: ${bin.x0.toFixed(2)}-${bin.x1.toFixed(2)}<br>` +
                                 `Category: ${categoryData.category}<br>` +
                                 `Frequency: ${categoryData.sum}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                        
                    // Highlight all bars with this category
                    d3.selectAll(`.feature-bar[data-category="${categoryData.category}"]`)
                        .classed("highlighted", true);
                })
                .on("mouseout", function() {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                        
                    // Reset highlighting
                    d3.selectAll(".feature-bar")
                        .classed("highlighted", false);
                });
                
            y0 += categoryData.sum; // Update starting y position for next stack
        });
    });
    
    // Create a container for the feature legend
    const featureLegendContainer = svg.append("g")
        .attr("class", "feature-legend-container")
        .attr("transform", `translate(${width + 20}, ${(categories.length + 2) * 20})`);

    // Add title for feature legend
    featureLegendContainer.append("text")
        .attr("class", "legend-title")
        .attr("y", -10)
        .attr("font-weight", "bold")
        .attr("font-size", "14px") // Match category font size
        .text("Features");
    
    // Add legend for features
    const featureLegend = featureLegendContainer.selectAll(".feature-legend")
        .data(allFeaturesSorted)
        .enter().append("g")
        .attr("class", "feature-legend-item")
        .attr("data-feature", d => d)
        .attr("transform", (d, i) => `translate(0, ${i * 20})`)
        .attr("font-size", "14px") // Match category font size
        .on("mouseenter", function(event, feature) {
            // Highlight the legend item
            d3.select(this).select("rect")
                .classed("highlighted", true);
            d3.select(this).select("text")
                .classed("highlighted", true);
                
            // Highlight all bars with this feature
            d3.selectAll(`.feature-bar[data-feature="${feature}"]`)
                .classed("highlighted", true);
                
            // Fade other features
            d3.selectAll(`.feature-bar:not([data-feature="${feature}"])`)
                .style("opacity", 0.3);
        })
        .on("mouseleave", function(event, feature) {
            // Reset legend highlighting
            d3.select(this).select("rect")
                .classed("highlighted", false);
            d3.select(this).select("text")
                .classed("highlighted", false);
                
            // Reset bar highlighting
            d3.selectAll(".feature-bar")
                .classed("highlighted", false)
                .style("opacity", 1);
        });

    featureLegend.append("rect")
        .attr("class", "legend-rect")
        .attr("width", 15)
        .attr("height", 15)
        .attr("fill", d => colorFeature(d));

    featureLegend.append("text")
        .attr("class", "legend-text")
        .attr("x", 20)
        .attr("y", 10)
        .text(d => {
            // Truncate long feature names for display
            return d && d.length > 25 ? d.substring(0, 22) + "..." : d;
        })
        .append("title") // Add full text as tooltip for truncated names
        .text(d => d);
        
    // Functions to save the visualization
    function saveSVG() {
        const svgData = new XMLSerializer().serializeToString(document.querySelector("svg"));
        const svgBlob = new Blob([svgData], {type: "image/svg+xml;charset=utf-8"});
        const svgUrl = URL.createObjectURL(svgBlob);
        const downloadLink = document.createElement("a");
        downloadLink.href = svgUrl;
        downloadLink.download = "{{figureName}}.svg";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
    }
    
    function savePDF() {
        const svgElement = document.querySelector('svg');
        const svgData = new XMLSerializer().serializeToString(svgElement);
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        // Scale factor for higher resolution (8x)
        const scaleFactor = 8;
        
        img.onload = function() {
            // Set canvas dimensions with scale factor for higher resolution
            canvas.width = svgElement.width.baseVal.value * scaleFactor;
            canvas.height = svgElement.height.baseVal.value * scaleFactor;
            
            // Scale the context to match the increased canvas size
            ctx.scale(scaleFactor, scaleFactor);
            ctx.drawImage(img, 0, 0);
            
            // Create PDF with proper dimensions
            const imgData = canvas.toDataURL('image/png', 1.0);
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
                unit: 'px',
                format: [svgElement.width.baseVal.value, svgElement.height.baseVal.value],
                hotfixes: ['px_scaling']
            });
            
            // Add image at original dimensions but with high-resolution data
            pdf.addImage(imgData, 'PNG', 0, 0, svgElement.width.baseVal.value, svgElement.height.baseVal.value, '', 'FAST');
            pdf.save('{{figureName}}.pdf');
        };
        
        img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
    }
    </script>
</body>
</html>
